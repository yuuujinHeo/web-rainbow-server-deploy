import { Parser as ParserV2 } from 'parserv2';
import { Parser as ParserV3 } from 'parserv3';
import { AvroSchemaParser } from '@asyncapi/avro-schema-parser';
import { OpenAPISchemaParser } from '@asyncapi/openapi-schema-parser';
import { RamlDTSchemaParser } from '@asyncapi/raml-dt-schema-parser';
import { ProtoBuffSchemaParser } from '@asyncapi/protobuf-schema-parser';
export function NewParser(parserAPIMajorVersion, options) {
    const parserOptions = (options === null || options === void 0 ? void 0 : options.parserOptions) || {};
    // This is done globally instead of per version because latest versions of those schema parsers are still compatible with newer versions of the Parser-JS.
    // If a breaking change is introduced in the future, then we would need to register the schema parsers compatible with each version of the Parser-JS.
    if (options === null || options === void 0 ? void 0 : options.includeSchemaParsers) {
        const defaultSchemaParsers = [
            AvroSchemaParser(),
            OpenAPISchemaParser(),
            RamlDTSchemaParser(),
            ProtoBuffSchemaParser(),
        ];
        if (!parserOptions.schemaParsers) {
            parserOptions.schemaParsers = defaultSchemaParsers;
        }
        else {
            // If the user provides a schema parser, use that one instead of the default one. Comparison is done with the mime types.
            const givenSchemaParsersMimeTypes = parserOptions.schemaParsers.map((schemaParser) => schemaParser.getMimeTypes()).flat();
            const filteredDefaultSchemas = defaultSchemaParsers.filter((defaultSchemaParser) => !givenSchemaParsersMimeTypes.includes(defaultSchemaParser.getMimeTypes()[0]));
            parserOptions.schemaParsers.push(...filteredDefaultSchemas);
        }
    }
    switch (parserAPIMajorVersion) {
        case 1:
            return new ParserV2(parserOptions);
        default: // default to latest version
        case 2:
            return new ParserV3(parserOptions);
    }
}
