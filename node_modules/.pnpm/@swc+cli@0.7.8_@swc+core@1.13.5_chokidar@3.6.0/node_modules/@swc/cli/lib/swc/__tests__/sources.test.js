"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sources_1 = require("../sources");
const fs_1 = __importDefault(require("fs"));
const tinyglobby_1 = require("tinyglobby");
jest.mock("fs");
jest.mock("tinyglobby");
describe("globSources", () => {
    beforeEach(() => {
        fs_1.default.resetMockStats();
    });
    it("exclude dotfiles sources when includeDotfiles=false", async () => {
        const files = await (0, sources_1.globSources)([".dotfile"], [], [], false);
        expect([...files]).toEqual([]);
    });
    it("include dotfiles sources when includeDotfiles=true", async () => {
        fs_1.default.setMockStats({ ".dotfile": { isDirectory: () => false } });
        const files = await (0, sources_1.globSources)([".dotfile"], [], [], true);
        expect([...files]).toEqual([".dotfile"]);
    });
    it("include multiple file sources", async () => {
        fs_1.default.setMockStats({ ".dotfile": { isDirectory: () => false } });
        fs_1.default.setMockStats({ file: { isDirectory: () => false } });
        const files = await (0, sources_1.globSources)([".dotfile", "file"], [], [], true);
        expect([...files]).toEqual([".dotfile", "file"]);
    });
    it("exclude files that errors on stats", async () => {
        fs_1.default.setMockStats({ ".dotfile": { isDirectory: () => false } });
        fs_1.default.setMockStats({ file: new Error("Failed stat") });
        const files = await (0, sources_1.globSources)([".dotfile", "file"], [], [], true);
        expect([...files]).toEqual([".dotfile"]);
    });
    it("includes all files from directory", async () => {
        fs_1.default.setMockStats({ directory: { isDirectory: () => true } });
        fs_1.default.setMockStats({ file: { isDirectory: () => false } });
        tinyglobby_1.glob.mockResolvedValue([
            "fileDir1",
            "fileDir2",
        ]);
        const files = await (0, sources_1.globSources)(["file", "directory"], [], [], true);
        expect([...files]).toEqual(["file", "fileDir1", "fileDir2"]);
    });
    it("exclude files from directory that fail to glob", async () => {
        fs_1.default.setMockStats({ directory: { isDirectory: () => true } });
        fs_1.default.setMockStats({ file: { isDirectory: () => false } });
        tinyglobby_1.glob.mockRejectedValue(new Error("Failed"));
        const files = await (0, sources_1.globSources)(["file", "directory"], [], [], true);
        expect([...files]).toEqual(["file"]);
    });
});
describe("splitCompilableAndCopyable", () => {
    const extensions = [".ts"];
    it("separate compilable and copyable when copyFiles=true", () => {
        const files = ["test.ts", "test.txt"];
        const [compilable, copyable] = (0, sources_1.splitCompilableAndCopyable)(files, extensions, true);
        expect(compilable).toEqual(["test.ts"]);
        expect(copyable).toEqual(["test.txt"]);
    });
    it("separate compilable and copyable when copyFiles=false", () => {
        const files = ["test.ts", "test.txt"];
        const [compilable, copyable] = (0, sources_1.splitCompilableAndCopyable)(files, extensions, false);
        expect(compilable).toEqual(["test.ts"]);
        expect(copyable).toEqual([]);
    });
});
